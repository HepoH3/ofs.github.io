

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Quick Start Guide &mdash; OPAE</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="OPAE" href="../../../index.html"/>
        <link rel="next" title="OPAE Installation Guide" href="../../install_guide/installation_guide.html"/>
        <link rel="prev" title="Open Programmable Acceleration Engine" href="../../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> OPAE
          

          
          </a>

          
            
            
              <div class="version">
                0.13.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">OPAE User Guides</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quick Start Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-the-opae-intel-fpga-drivers">Installing the OPAE Intel® FPGA drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-the-opae-sdk-from-rpm-packages">Installing the OPAE SDK from rpm packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-installing-the-opae-sdk-from-source">Building and installing the OPAE SDK from source</a></li>
<li class="toctree-l2"><a class="reference internal" href="#configuring-the-fpga-loading-an-fpga-afu">Configuring the FPGA (loading an FPGA AFU)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#building-a-sample-application">Building a sample application</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../install_guide/installation_guide.html">OPAE Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prog_guide/readme.html">OPAE C API Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ase_userguide/ase_userguide.html">Intel® Accelerator Functional Unit (AFU) Simulation Environment (ASE) User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">OPAE Libraries</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../build_chain/fpga_api/api_build.html">Building the OPAE C Library</a></li>
</ul>
<p class="caption"><span class="caption-text">OPAE Linux Kernel Drivers</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../drv_arch/drv_arch.html">Open Programmable Accelerator Engine (OPAE) Linux Device Driver Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../drv_arch/drv_arch.html#sysfs-files">sysfs files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build_chain/fpga_driver/driver_build.html">Building the OPAE Intel FPGA driver (in-tree)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../build_chain/fpga_driver/driver_build.html#building-the-opae-intel-fpga-driver-out-of-tree">Building the OPAE Intel FPGA driver (out-of-tree)</a></li>
</ul>
<p class="caption"><span class="caption-text">OPAE FPGA Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/coreidle/coreidle.html">coreidle</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgabist/fpgabist.html">fpgabist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgainfo/fpgainfo.html">fpgainfo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgaconf/fpgaconf.html">fpgaconf</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgad/fpgad.html">fpgad</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgadiag/README.html">fpgadiag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgaflash/fpgaflash.html">fpgaflash</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgamux/fpgamux.html">fpgamux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/fpgaport/fpgaport.html">fpgaport</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/mmlink/mmlink.html">mmlink</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/packager/packager.html">packager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/userclk/userclk.html">userclk</a></li>
</ul>
<p class="caption"><span class="caption-text">OPAE AFU Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/hssi_config/readme.html">hssi_config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fpga_tools/hssi_loopback/readme.html">hssi_loopback</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OPAE</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
      <li>Quick Start Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/docs/fpga_api/quick_start/readme.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="quick-start-guide">
<h1>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The OPAE C library is a lightweight user-space library that provides
abstraction for FPGA resources in a compute environment. Built on top of
the OPAE Intel® FPGA driver stack that supports Intel® FPGA platforms,
the library abstracts away hardware specific and OS specific details and
exposes the underlying FPGA resources as a set of features accessible
from within software programs running on the host.</p>
<p>These features include the acceleration logic preconfigured on the
device, as well as functions to manage and reconfigure the device.
Hence, the library is able to enalbe user applications to transparently
and seamlessly leverage FPGA-based acceleration.</p>
<p>In this document, we will explore the initial steps on how to setup the
required libraries and utilities to use the FPGA devices.</p>
</div>
<div class="section" id="installing-the-opae-intel-fpga-drivers">
<h2>Installing the OPAE Intel® FPGA drivers<a class="headerlink" href="#installing-the-opae-intel-fpga-drivers" title="Permalink to this headline">¶</a></h2>
<p>If you do not have access to an Intel® Xeon® processor with integrated
FPGA, or a programmable FPGA acceleration card for Intel® Xeon®
processors, you will not be able to run the examples below. However, you
can still make use of the AFU simulation environment (ASE) to develop
and test accelerator RTL with OPAE applications.</p>
<p>For more information about ASE, see the <a class="reference external" href="../../ase_userguide/ase_userguide.html">OPAE AFU Simulation Environment
(ASE) User Guide</a>.</p>
<p>As part of the OPAE SDK release, we provide a DKMS-based RPM package for
distributions using RPM (e.g. Redhat, Fedora, Centos) package managers.
Download this package from the respective <a class="reference external" href="https://github.com/OPAE/opae-sdk/releases">release page on
GitHub</a> - it is named
<code class="docutils literal"><span class="pre">opae-intel-fpga-drv-x.y.z-1.x86_64.rpm</span></code>, with <code class="docutils literal"><span class="pre">x.y.z</span></code> being the
respective OPAE release’s version number.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">The RPM package requires that the DKMS (Dynamic Kernel Module System)</span>
<span class="go">package, version greater than 2.2, is already installed.</span>
</pre></div>
</div>
<p>For Redhat and Centos:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo yum install opae-intel-fpga-drv-&lt;release&gt;-1.x86_64.rpm
</pre></div>
</div>
</div>
<div class="section" id="installing-the-opae-sdk-from-rpm-packages">
<h2>Installing the OPAE SDK from rpm packages<a class="headerlink" href="#installing-the-opae-sdk-from-rpm-packages" title="Permalink to this headline">¶</a></h2>
<p>See the <a class="reference external" href="/fpga-doc/docs/fpga_api/install_guide/installation_guide.html">OPAE Installation
Guide</a>
for information about OPAE RPM packages. Assuming RPM packages are
already downloaded and exist in the current folder, then use the
commands below to install the OPAE library, tools, and development
headers.</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo yum install opae-&lt;release&gt;-1.x86_64-libs.rpm
<span class="gp">$</span> sudo yum install opae-&lt;release&gt;-1.x86_64-tools.rpm
<span class="gp">$</span> sudo yum install opae-&lt;release&gt;-1.x86_64-devel.rpm
</pre></div>
</div>
<p>To use OPAE in the simulation environment, you also need to install the
AFU Simulation Environment (ASE) package:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo yum install opae-&lt;release&gt;-1.x86_64-ase.rpm
</pre></div>
</div>
</div>
<div class="section" id="building-and-installing-the-opae-sdk-from-source">
<h2>Building and installing the OPAE SDK from source<a class="headerlink" href="#building-and-installing-the-opae-sdk-from-source" title="Permalink to this headline">¶</a></h2>
<p>Download the OPAE SDK source package from the respective <a class="reference external" href="https://github.com/OPAE/opae-sdk/releases">release page
on GitHub</a> - click the
<code class="docutils literal"><span class="pre">Source</span> <span class="pre">code</span> <span class="pre">(tar.gz)</span></code> link under “Downloads”.</p>
<p>After downloading the source, unpack, configure, and compile it:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="go">tar xfvz opae-sdk-&lt;release&gt;.tar.gz</span>
<span class="go">cd opae-sdk-&lt;release&gt;</span>
<span class="go">mkdir mybuild</span>
<span class="go">cd mybuild</span>
<span class="go">cmake .. -DBUILD_ASE=1</span>
<span class="go">make</span>
</pre></div>
</div>
<p>By default, the OPAE SDK will install into <code class="docutils literal"><span class="pre">/usr/local</span></code> if you also
issue the following:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="go">make install</span>
</pre></div>
</div>
<p>You can change this installation prefix from <code class="docutils literal"><span class="pre">/usr/local</span></code> into
something else by adding <code class="docutils literal"><span class="pre">-DCMAKE_INSTALL_PREFIX=&lt;new</span> <span class="pre">prefix&gt;</span></code> to the
<code class="docutils literal"><span class="pre">cmake</span></code> command above. The remainder of this guide assumes you
installed into <code class="docutils literal"><span class="pre">/usr/local</span></code>.</p>
</div>
<div class="section" id="configuring-the-fpga-loading-an-fpga-afu">
<h2>Configuring the FPGA (loading an FPGA AFU)<a class="headerlink" href="#configuring-the-fpga-loading-an-fpga-afu" title="Permalink to this headline">¶</a></h2>
<p>The <em>fpgaconf</em> tool exercises the AFU reconfiguration functionality. It
shows how to read a bitstream from a disk file, check its validity and
compatability, and then injects it into FPGA to be configured as a new
AFU, which can then be discovered and used by user applications.</p>
<p>For this step you require a valid green bitstream (GBS) file. To
reconfigure the FPGA slot, you can issue following command as system
administrator (<em>root</em>):</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo fpgaconf -b 0x5e &lt;filename&gt;.gbs
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-b</span></code> parameter to <em>fpgaconf</em> indicates the <em>target bus number</em> of
the FPGA slot to be reconfigured. Alternatively, you can also specify
the <em>target socket number</em> of the FPGA using the <code class="docutils literal"><span class="pre">-s</span></code> parameter.</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo fpgaconf --help
<span class="go">Usage:</span>
<span class="go">        fpgaconf [-hvn] [-b &lt;bus&gt;] [-d &lt;device&gt;] [-f &lt;function&gt;] [-s &lt;socket&gt;] &lt;gbs&gt;</span>

<span class="go">                -h,--help           Print this help</span>
<span class="go">                -v,--verbose        Increase verbosity</span>
<span class="go">                -n,--dry-run        Don&#39;t actually perform actions</span>
<span class="go">                -b,--bus            Set target bus number</span>
<span class="go">                -d,--device         Set target device number</span>
<span class="go">                -f,--function       Set target function number</span>
<span class="go">                -s,--socket         Set target socket number</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">The sample application on the Building a Sample Application</span>
<span class="go">section requires loading of an AFU called &quot;Native Loopback</span>
<span class="go">Adapter&quot; (NLB) on the FPGA. Please refer to the NLB documentation</span>
<span class="go">for the location of the NLB&#39;s green bitstream. You also can verify</span>
<span class="go">if the NLB green bitstream has already been loaded into the FPGA</span>
<span class="go">slot by typing the following command and checking the output</span>
<span class="go">matches the following:</span>

<span class="gp">$</span> cat /sys/class/fpga/intel-fpga-dev.0/intel-fpga-port.0/afu_id

<span class="go">d8424dc4a4a3c413f89e433683f9040b</span>
</pre></div>
</div>
</div>
<div class="section" id="building-a-sample-application">
<h2>Building a sample application<a class="headerlink" href="#building-a-sample-application" title="Permalink to this headline">¶</a></h2>
<p>The library source include code samples. Use these samples to learn how
to call functions in the library. Build and run these samples as quick
sanity checks to determine if your installation and environment are set
up properly.</p>
<p>In this guide, we will build <em>hello_fpga.c</em>. This is the “Hello World!”
example of using the library. This code searches for a predefined and
known AFU called “Native Loopback Adapter” on the FPGA. If found, it
acquires ownership and then interacts with the AFU by sending it a 2MB
message and waiting for the message being echoed back. This coe
exercises all major components of the API except for AFU
reconfiguration: AFU search, enumeration, access, MMIO, and memory
management.</p>
<p>You can also find the source for <code class="docutils literal"><span class="pre">hello\_fpga</span></code> in the <code class="docutils literal"><span class="pre">samples</span></code>
directory of the OPAE SDK repository on github.</p>
<div class="code c highlight-console"><div class="highlight"><pre><span></span><span class="go">int main(int argc, char *argv[])</span>
<span class="go">{</span>
<span class="go">    fpga_properties    filter = NULL;</span>
<span class="go">    fpga_token         afc_token;</span>
<span class="go">    fpga_handle        afc_handle;</span>
<span class="go">    fpga_guid          guid;</span>
<span class="go">    uint32_t           num_matches;</span>

<span class="go">    volatile uint64_t *dsm_ptr    = NULL;</span>
<span class="go">    volatile uint64_t *status_ptr = NULL;</span>
<span class="go">    volatile uint64_t *input_ptr  = NULL;</span>
<span class="go">    volatile uint64_t *output_ptr = NULL;</span>

<span class="go">    uint64_t        dsm_wsid;</span>
<span class="go">    uint64_t        input_wsid;</span>
<span class="go">    uint64_t        output_wsid;</span>
<span class="go">    fpga_result     res = FPGA_OK;</span>

<span class="go">    if (uuid_parse(NLB0_AFUID, guid) &lt; 0) {</span>
<span class="go">        fprintf(stderr, &quot;Error parsing guid &#39;%s&#39;\n&quot;, NLB0_AFUID);</span>
<span class="go">        goto out_exit;</span>
<span class="go">    }</span>

<span class="go">    /* Look for AFC with MY_AFC_ID */</span>
<span class="go">    res = fpgaGetProperties(NULL, &amp;filter);</span>
<span class="go">    ON_ERR_GOTO(res, out_exit, &quot;creating properties object&quot;);</span>

<span class="go">    res = fpgaPropertiesSetObjectType(filter, FPGA_AFC);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_prop, &quot;setting object type&quot;);</span>

<span class="go">    res = fpgaPropertiesSetGuid(filter, guid);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_prop, &quot;setting GUID&quot;);</span>

<span class="go">    /* TODO: Add selection via BDF / device ID */</span>

<span class="go">    res = fpgaEnumerate(&amp;filter, 1, &amp;afc_token, 1, &amp;num_matches);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_prop, &quot;enumerating AFCs&quot;);</span>

<span class="go">    if (num_matches &lt; 1) {</span>
<span class="go">        fprintf(stderr, &quot;AFC not found.\n&quot;);</span>
<span class="go">        res = fpgaDestroyProperties(&amp;filter);</span>
<span class="go">        return FPGA_INVALID_PARAM;</span>
<span class="go">    }</span>

<span class="go">    /* Open AFC and map MMIO */</span>
<span class="go">    res = fpgaOpen(afc_token, &amp;afc_handle, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_tok, &quot;opening AFC&quot;);</span>

<span class="go">    res = fpgaMapMMIO(afc_handle, 0, NULL);</span>
<span class="go">    ON_ERR_GOTO(res, out_close, &quot;mapping MMIO space&quot;);</span>

<span class="go">    /* Allocate buffers */</span>
<span class="go">    res = fpgaPrepareBuffer(afc_handle, LPBK1_DSM_SIZE,</span>
<span class="go">                (void **)&amp;dsm_ptr, &amp;dsm_wsid, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_close, &quot;allocating DSM buffer&quot;);</span>

<span class="go">    res = fpgaPrepareBuffer(afc_handle, LPBK1_BUFFER_ALLOCATION_SIZE,</span>
<span class="go">               (void **)&amp;input_ptr, &amp;input_wsid, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_dsm, &quot;allocating input buffer&quot;);</span>

<span class="go">    res = fpgaPrepareBuffer(afc_handle, LPBK1_BUFFER_ALLOCATION_SIZE,</span>
<span class="go">               (void **)&amp;output_ptr, &amp;output_wsid, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_input, &quot;allocating output buffer&quot;);</span>

<span class="go">    printf(&quot;Running Test\n&quot;);</span>

<span class="go">    /* Initialize buffers */</span>
<span class="go">    memset((void *)dsm_ptr,    0,    LPBK1_DSM_SIZE);</span>
<span class="go">    memset((void *)input_ptr,  0xAF, LPBK1_BUFFER_SIZE);</span>
<span class="go">    memset((void *)output_ptr, 0xBE, LPBK1_BUFFER_SIZE);</span>

<span class="go">    cache_line *cl_ptr = (cache_line *)input_ptr;</span>
<span class="go">    for (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE / CL(1); ++i) {</span>
<span class="go">        cl_ptr[i].uint[15] = i+1; /* set the last uint in every cacheline */</span>
<span class="go">    }</span>

<span class="go">    /* Reset AFC */</span>
<span class="go">    res = fpgaReset(afc_handle);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;resetting AFC&quot;);</span>

<span class="go">    /* Program DMA addresses */</span>
<span class="go">    uint64_t iova;</span>
<span class="go">    res = fpgaGetIOVA(afc_handle, dsm_wsid, &amp;iova);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;getting DSM IOVA&quot;);</span>

<span class="go">    res = fpgaWriteMMIO64(afc_handle, 0, CSR_AFU_DSM_BASEL, iova);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_AFU_DSM_BASEL&quot;);</span>

<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_CTL, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_CFG&quot;);</span>
<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_CTL, 1);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_CFG&quot;);</span>

<span class="go">    res = fpgaGetIOVA(afc_handle, input_wsid, &amp;iova);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;getting input IOVA&quot;);</span>
<span class="go">    res = fpgaWriteMMIO64(afc_handle, 0, CSR_SRC_ADDR, CACHELINE_ALIGNED_ADDR(iova));</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_SRC_ADDR&quot;);</span>

<span class="go">    res = fpgaGetIOVA(afc_handle, output_wsid, &amp;iova);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;getting output IOVA&quot;);</span>
<span class="go">    res = fpgaWriteMMIO64(afc_handle, 0, CSR_DST_ADDR, CACHELINE_ALIGNED_ADDR(iova));</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_DST_ADDR&quot;);</span>
<span class="go">    //fpgaProgramBufferAddressAndLength(afc_handle, dsm_wsid, 0, LPBK1_DSM_SIZE,</span>
<span class="go">    //                 CSR_AFU_DSM_BASEL);</span>
<span class="go">    //fpgaProgramBufferAddressAndLength(afc_handle, input_wsid, 0, LPBK1_BUFFER_SIZE,</span>
<span class="go">    //                 CSR_SRC_ADDR);</span>
<span class="go">    //fpgaProgramBufferAddressAndLength(afc_handle, output_wsid, 0, LPBK1_BUFFER_SIZE,</span>
<span class="go">    //                 CSR_DST_ADDR);</span>

<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_NUM_LINES, LPBK1_BUFFER_SIZE / CL(1));</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_NUM_LINES&quot;);</span>
<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_CFG, 0x42000);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_CFG&quot;);</span>

<span class="go">    status_ptr = dsm_ptr + DSM_STATUS_TEST_COMPLETE/8;</span>

<span class="go">    /* Start the test */</span>
<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_CTL, 3);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_CFG&quot;);</span>

<span class="go">    /* Wait for test completion */</span>
<span class="go">    while (0 == ((*status_ptr) &amp; 0x1)) {</span>
<span class="go">        usleep(100);</span>
<span class="go">    }</span>

<span class="go">    /* Stop the device */</span>
<span class="go">    res = fpgaWriteMMIO32(afc_handle, 0, CSR_CTL, 7);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_output, &quot;writing CSR_CFG&quot;);</span>

<span class="go">    /* Check output buffer contents */</span>
<span class="go">    for (uint32_t i = 0; i &lt; LPBK1_BUFFER_SIZE; i++) {</span>
<span class="go">        if (((uint8_t*)output_ptr)[i] != ((uint8_t*)input_ptr)[i]) {</span>
<span class="go">            fprintf(stderr, &quot;Output does NOT match input &quot;</span>
<span class="go">                &quot;at offset %i!\n&quot;, i);</span>
<span class="go">            break;</span>
<span class="go">        }</span>
<span class="go">    }</span>

<span class="go">    printf(&quot;Done Running Test\n&quot;);</span>

<span class="go">    /* Release buffers */</span>
<span class="go">out_free_output:</span>
<span class="go">    res = fpgaReleaseBuffer(afc_handle, output_wsid);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_input, &quot;releasing output buffer&quot;);</span>
<span class="go">out_free_input:</span>
<span class="go">    res = fpgaReleaseBuffer(afc_handle, input_wsid);</span>
<span class="go">    ON_ERR_GOTO(res, out_free_dsm, &quot;releasing input buffer&quot;);</span>
<span class="go">out_free_dsm:</span>
<span class="go">    res = fpgaReleaseBuffer(afc_handle, dsm_wsid);</span>
<span class="go">    ON_ERR_GOTO(res, out_unmap, &quot;releasing DSM buffer&quot;);</span>

<span class="go">    /* Unmap MMIO space */</span>
<span class="go">out_unmap:</span>
<span class="go">    res = fpgaUnmapMMIO(afc_handle, 0);</span>
<span class="go">    ON_ERR_GOTO(res, out_close, &quot;unmapping MMIO space&quot;);</span>

<span class="go">    /* Release accelerator */</span>
<span class="go">out_close:</span>
<span class="go">    res = fpgaClose(afc_handle);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_tok, &quot;closing AFC&quot;);</span>

<span class="go">    /* Destroy token */</span>
<span class="go">out_destroy_tok:</span>
<span class="go">    res = fpgaDestroyToken(&amp;afc_token);</span>
<span class="go">    ON_ERR_GOTO(res, out_destroy_prop, &quot;destroying token&quot;);</span>

<span class="go">    /* Destroy properties object */</span>
<span class="go">out_destroy_prop:</span>
<span class="go">    res = fpgaDestroyProperties(&amp;filter);</span>
<span class="go">    ON_ERR_GOTO(res, out_exit, &quot;destroying properties object&quot;);</span>

<span class="go">out_exit:</span>
<span class="go">    return res;</span>

<span class="go">}</span>
</pre></div>
</div>
<p>Linking with the OPAE library is straightforward. Code using this
library should include the header file <code class="docutils literal"><span class="pre">fpga.h</span></code>. Taking the GCC
compiler on Linux as an example, the minimalist compile and link line
should look like:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> gcc -std<span class="o">=</span>c99 hello_fpga.c -I/usr/local/include -L/usr/local/lib -lopae-c -luuid -ljson-c -lpthread -o hello_fpga
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">The API uses some features from the C99 language standard. The</span>
<span class="go">`-std=c99` switch is required if the compiler does not support C99 by</span>
<span class="go">default.</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">Third-party library dependency: The library internally uses</span>
<span class="go">`libuuid` and `libjson-c`. But they are not distributed as part of the</span>
<span class="go">library. Make sure you have these libraries properly installed.</span>
</pre></div>
</div>
<p>To run the <em>hello_fpga</em> application; just issue:</p>
<div class="code console highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo ./hello_fpga

<span class="go">Running Test</span>
<span class="go">Done</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">In order to successfully run hello\_fpga, user need to configure system hugepage to reserve 2M-hugepages.</span>
<span class="go">For example, the command below reserves 20 2M-hugepages:</span>

<span class="gp">$</span> <span class="nb">echo</span> <span class="m">20</span> <span class="p">|</span> sudo tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages

<span class="go">For x86_64 architecture CPU, user can use following command to find out avaiable huge page sizes:</span>

<span class="gp">$</span> grep pse /proc/cpuinfo <span class="p">|</span> uniq
<span class="go">flags : ... pse ...</span>

<span class="go">If this commands returns a non-empty string, 2MB pages are supported:</span>

<span class="gp">$</span> grep pse /proc/cpuinfo <span class="p">|</span> uniq
<span class="go">flags : ... pdpe1gb ...</span>

<span class="go">If this commands returns a non-empty string, 1GB pages are supported:</span>
</pre></div>
</div>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">The default configuration for many Linux distribution currently sets a relatively low limit for pinned memory allocations per process (RLIMIT_MEMLOCK, often set to a default of 64kiB).</span>
<span class="go">To run an OPAE application which attempts to share more memory than specified by this limit between software and an accelerator, you can either:</span>

<span class="go">   * Run the application as root, or</span>
<span class="go">   * Increase the limit for locked memory via ulimit:</span>

<span class="gp">   $</span> <span class="nb">ulimit</span> -l unlimited

<span class="go">See the Installation Guide for how to permanently adjust the memlock limit.</span>
</pre></div>
</div>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../install_guide/installation_guide.html" class="btn btn-neutral float-right" title="OPAE Installation Guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../../../index.html" class="btn btn-neutral" title="Open Programmable Acceleration Engine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017 Intel Corporation.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.13.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>